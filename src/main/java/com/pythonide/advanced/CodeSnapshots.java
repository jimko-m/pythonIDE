package com.pythonide.advanced;

import java.io.*;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.security.MessageDigest;
import java.util.zip.*;

/**
 * Code Snapshots Management System
 * Provides intelligent code versioning, comparison, and rollback capabilities
 */
public class CodeSnapshots {
    
    public static class CodeSnapshot {
        private String id;
        private String name;
        private String description;
        private String code;
        private String filePath;
        private LocalDateTime timestamp;
        private String author;
        private Map<String, String> metadata;
        private String fileHash;
        private long fileSize;
        private List<String> tags;
        private boolean isAutomatic;
        private String parentSnapshotId;
        
        public CodeSnapshot(String code, String filePath) {
            this.id = generateId();
            this.code = code;
            this.filePath = filePath;
            this.timestamp = LocalDateTime.now();
            this.metadata = new HashMap<>();
            this.tags = new ArrayList<>();
            this.isAutomatic = false;
            this.parentSnapshotId = null;
            this.fileHash = calculateHash(code);
            this.fileSize = code.getBytes().length;\n        }\n        \n        public CodeSnapshot(String code, String filePath, String name, String description) {\n            this(code, filePath);\n            this.name = name != null ? name : generateDefaultName();\n            this.description = description != null ? description : \"\";\n        }\n        \n        private String generateId() {\n            return \"snap_\" + System.currentTimeMillis() + \"_\" + Math.random();\n        }\n        \n        private String generateDefaultName() {\n            return \"Snapshot \" + timestamp.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\n        }\n        \n        private String calculateHash(String content) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n                byte[] hash = md.digest(content.getBytes());\n                StringBuilder hexString = new StringBuilder();\n                for (byte b : hash) {\n                    String hex = Integer.toHexString(0xff & b);\n                    if (hex.length() == 1) hexString.append('0');\n                    hexString.append(hex);\n                }\n                return hexString.toString();\n            } catch (Exception e) {\n                return \"\";\n            }\n        }\n        \n        public void addTag(String tag) {\n            if (!tags.contains(tag)) {\n                tags.add(tag);\n            }\n        }\n        \n        public void removeTag(String tag) {\n            tags.remove(tag);\n        }\n        \n        public void addMetadata(String key, String value) {\n            metadata.put(key, value);\n        }\n        \n        public String getMetadata(String key) {\n            return metadata.get(key);\n        }\n        \n        // Getters\n        public String getId() { return id; }\n        public String getName() { return name; }\n        public void setName(String name) { this.name = name; }\n        public String getDescription() { return description; }\n        public void setDescription(String description) { this.description = description; }\n        public String getCode() { return code; }\n        public void setCode(String code) { this.code = code; }\n        public String getFilePath() { return filePath; }\n        public void setFilePath(String filePath) { this.filePath = filePath; }\n        public LocalDateTime getTimestamp() { return timestamp; }\n        public String getAuthor() { return author; }\n        public void setAuthor(String author) { this.author = author; }\n        public Map<String, String> getMetadata() { return metadata; }\n        public String getFileHash() { return fileHash; }\n        public long getFileSize() { return fileSize; }\n        public List<String> getTags() { return tags; }\n        public boolean isAutomatic() { return isAutomatic; }\n        public void setAutomatic(boolean automatic) { isAutomatic = automatic; }\n        public String getParentSnapshotId() { return parentSnapshotId; }\n        public void setParentSnapshotId(String parentId) { this.parentSnapshotId = parentId; }\n        \n        public String getFormattedTimestamp() {\n            return timestamp.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));\n        }\n        \n        public long getAgeInMinutes() {\n            return java.time.Duration.between(timestamp, LocalDateTime.now()).toMinutes();\n        }\n        \n        public String getFormattedSize() {\n            if (fileSize < 1024) return fileSize + \" bytes\";\n            if (fileSize < 1024 * 1024) return String.format(\"%.1f KB\", fileSize / 1024.0);\n            return String.format(\"%.1f MB\", fileSize / (1024.0 * 1024.0));\n        }\n        \n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"ID: \").append(id).append(\"\\n\");\n            sb.append(\"Name: \").append(name).append(\"\\n\");\n            sb.append(\"File: \").append(filePath).append(\"\\n\");\n            sb.append(\"Timestamp: \").append(getFormattedTimestamp()).append(\"\\n\");\n            sb.append(\"Size: \").append(getFormattedSize()).append(\"\\n\");\n            sb.append(\"Tags: \").append(String.join(\", \", tags)).append(\"\\n\");\n            sb.append(\"Description: \").append(description);\n            return sb.toString();\n        }\n    }\n    \n    public static class SnapshotComparison {\n        private CodeSnapshot oldSnapshot;\n        private CodeSnapshot newSnapshot;\n        private List<DiffChange> changes;\n        private double similarity;\n        \n        public enum ChangeType {\n            ADDED(\"إضافة\"),\n            MODIFIED(\"تعديل\"),\n            DELETED(\"حذف\"),\n            UNCHANGED(\"بدون تغيير\");\n            \n            private final String displayName;\n            \n            ChangeType(String displayName) {\n                this.displayName = displayName;\n            }\n            \n            public String getDisplayName() {\n                return displayName;\n            }\n        }\n        \n        public static class DiffChange {\n            private ChangeType type;\n            private int lineNumber;\n            private String oldContent;\n            private String newContent;\n            private String context;\n            \n            public DiffChange(ChangeType type, int lineNumber, String oldContent, String newContent, String context) {\n                this.type = type;\n                this.lineNumber = lineNumber;\n                this.oldContent = oldContent;\n                this.newContent = newContent;\n                this.context = context;\n            }\n            \n            // Getters\n            public ChangeType getType() { return type; }\n            public int getLineNumber() { return lineNumber; }\n            public String getOldContent() { return oldContent; }\n            public String getNewContent() { return newContent; }\n            public String getContext() { return context; }\n        }\n        \n        public SnapshotComparison(CodeSnapshot oldSnapshot, CodeSnapshot newSnapshot) {\n            this.oldSnapshot = oldSnapshot;\n            this.newSnapshot = newSnapshot;\n            this.changes = new ArrayList<>();\n            calculateChanges();\n            calculateSimilarity();\n        }\n        \n        private void calculateChanges() {\n            String[] oldLines = oldSnapshot.getCode().split(\"\\r?\\n\");\n            String[] newLines = newSnapshot.getCode().split(\"\\r?\\n\");\n            \n            int maxLines = Math.max(oldLines.length, newLines.length);\n            \n            for (int i = 0; i < maxLines; i++) {\n                String oldLine = i < oldLines.length ? oldLines[i] : null;\n                String newLine = i < newLines.length ? newLines[i] : null;\n                \n                ChangeType changeType;\n                String context = i > 0 ? oldLines[i-1] : (i > 1 ? oldLines[i-2] : \"\");\n                \n                if (oldLine == null && newLine != null) {\n                    changeType = ChangeType.ADDED;\n                    changes.add(new DiffChange(changeType, i + 1, null, newLine, context));\n                } else if (oldLine != null && newLine == null) {\n                    changeType = ChangeType.DELETED;\n                    changes.add(new DiffChange(changeType, i + 1, oldLine, null, context));\n                } else if (!oldLine.equals(newLine)) {\n                    changeType = ChangeType.MODIFIED;\n                    changes.add(new DiffChange(changeType, i + 1, oldLine, newLine, context));\n                }\n            }\n        }\n        \n        private void calculateSimilarity() {\n            String[] oldLines = oldSnapshot.getCode().split(\"\\r?\\n\");\n            String[] newLines = newSnapshot.getCode().split(\"\\r?\\n\");\n            \n            int totalLines = Math.max(oldLines.length, newLines.length);\n            int identicalLines = 0;\n            \n            for (int i = 0; i < totalLines; i++) {\n                String oldLine = i < oldLines.length ? oldLines[i] : \"\";\n                String newLine = i < newLines.length ? newLines[i] : \"\";\n                if (oldLine.equals(newLine)) {\n                    identicalLines++;\n                }\n            }\n            \n            similarity = totalLines > 0 ? (double) identicalLines / totalLines : 1.0;\n        }\n        \n        public int getAddedLines() {\n            return (int) changes.stream().filter(c -> c.getType() == ChangeType.ADDED).count();\n        }\n        \n        public int getDeletedLines() {\n            return (int) changes.stream().filter(c -> c.getType() == ChangeType.DELETED).count();\n        }\n        \n        public int getModifiedLines() {\n            return (int) changes.stream().filter(c -> c.getType() == ChangeType.MODIFIED).count();\n        }\n        \n        public String getFormattedDiff() {\n            StringBuilder diff = new StringBuilder();\n            diff.append(\"=== مقارنة اللقطات ===\\n\");\n            diff.append(\"من: \").append(oldSnapshot.getName()).append(\"\\n\");\n            diff.append(\"إلى: \").append(newSnapshot.getName()).append(\"\\n\");\n            diff.append(\"التشابه: \").append(String.format(\"%.1f%%\", similarity * 100)).append(\"\\n\\n\");\n            \n            diff.append(\"الملخص:\\n\");\n            diff.append(\"- الأسطر المضافة: \").append(getAddedLines()).append(\"\\n\");\n            diff.append(\"- الأسطر المحذوفة: \").append(getDeletedLines()).append(\"\\n\");\n            diff.append(\"- الأسطر المعدلة: \").append(getModifiedLines()).append(\"\\n\\n\");\n            \n            diff.append(\"التفاصيل:\\n\");\n            for (DiffChange change : changes) {\n                switch (change.getType()) {\n                    case ADDED:\n                        diff.append(\"+\").append(change.getLineNumber()).append(\": + \").append(change.getNewContent()).append(\"\\n\");\n                        break;\n                    case DELETED:\n                        diff.append(\"-\").append(change.getLineNumber()).append(\": - \").append(change.getOldContent()).append(\"\\n\");\n                        break;\n                    case MODIFIED:\n                        diff.append(\"~\").append(change.getLineNumber()).append(\":\");\n                        diff.append(\" [كان: \").append(change.getOldContent()).append(\"]\");\n                        diff.append(\" [أصبح: \").append(change.getNewContent()).append(\"]\\n\");\n                        break;\n                }\n            }\n            \n            return diff.toString();\n        }\n        \n        // Getters\n        public CodeSnapshot getOldSnapshot() { return oldSnapshot; }\n        public CodeSnapshot getNewSnapshot() { return newSnapshot; }\n        public List<DiffChange> getChanges() { return changes; }\n        public double getSimilarity() { return similarity; }\n    }\n    \n    public interface SnapshotListener {\n        void onSnapshotCreated(CodeSnapshot snapshot);\n        void onSnapshotDeleted(String snapshotId);\n        void onSnapshotRestored(CodeSnapshot snapshot);\n    }\n    \n    private Map<String, CodeSnapshot> snapshots;\n    private Map<String, List<String>> fileSnapshots;\n    private List<SnapshotListener> listeners;\n    private String storagePath;\n    private boolean autoBackupEnabled;\n    private int maxAutoSnapshots;\n    \n    public CodeSnapshots(String storagePath) {\n        this.storagePath = storagePath;\n        this.snapshots = new HashMap<>();\n        this.fileSnapshots = new HashMap<>();\n        this.listeners = new ArrayList<>();\n        this.autoBackupEnabled = true;\n        this.maxAutoSnapshots = 10;\n        \n        loadSnapshots();\n    }\n    \n    /**\n     * Create a manual snapshot\n     */\n    public CompletableFuture<CodeSnapshot> createSnapshot(String code, String filePath, String name, String description) {\n        return CompletableFuture.supplyAsync(() -> {\n            CodeSnapshot snapshot = new CodeSnapshot(code, filePath, name, description);\n            snapshot.setAuthor(getCurrentUser());\n            \n            snapshots.put(snapshot.getId(), snapshot);\n            fileSnapshots.computeIfAbsent(filePath, k -> new ArrayList<>()).add(snapshot.getId());\n            \n            saveSnapshot(snapshot);\n            notifySnapshotCreated(snapshot);\n            \n            return snapshot;\n        });\n    }\n    \n    /**\n     * Create automatic snapshot (called before code changes)\n     */\n    public CompletableFuture<CodeSnapshot> createAutoSnapshot(String code, String filePath) {\n        return CompletableFuture.supplyAsync(() -> {\n            CodeSnapshot snapshot = new CodeSnapshot(code, filePath);\n            snapshot.setAutomatic(true);\n            snapshot.setName(\"Auto Backup - \" + snapshot.getFormattedTimestamp());\n            snapshot.setDescription(\"Automatic backup before changes\");\n            \n            // Clean up old auto snapshots if needed\n            cleanupAutoSnapshots(filePath);\n            \n            snapshots.put(snapshot.getId(), snapshot);\n            fileSnapshots.computeIfAbsent(filePath, k -> new ArrayList<>()).add(snapshot.getId());\n            \n            saveSnapshot(snapshot);\n            notifySnapshotCreated(snapshot);\n            \n            return snapshot;\n        });\n    }\n    \n    /**\n     * Get snapshots for a specific file\n     */\n    public List<CodeSnapshot> getSnapshotsForFile(String filePath) {\n        List<String> snapshotIds = fileSnapshots.get(filePath);\n        if (snapshotIds == null) {\n            return new ArrayList<>();\n        }\n        \n        return snapshotIds.stream()\n                .map(snapshots::get)\n                .filter(Objects::nonNull)\n                .sorted((s1, s2) -> s2.getTimestamp().compareTo(s1.getTimestamp()))\n                .collect(Collectors.toList());\n    }\n    \n    /**\n     * Get all snapshots\n     */\n    public List<CodeSnapshot> getAllSnapshots() {\n        return snapshots.values().stream()\n                .sorted((s1, s2) -> s2.getTimestamp().compareTo(s1.getTimestamp()))\n                .collect(Collectors.toList());\n    }\n    \n    /**\n     * Get snapshot by ID\n     */\n    public CodeSnapshot getSnapshotById(String id) {\n        return snapshots.get(id);\n    }\n    \n    /**\n     * Compare two snapshots\n     */\n    public SnapshotComparison compareSnapshots(String oldSnapshotId, String newSnapshotId) {\n        CodeSnapshot oldSnapshot = snapshots.get(oldSnapshotId);\n        CodeSnapshot newSnapshot = snapshots.get(newSnapshotId);\n        \n        if (oldSnapshot == null || newSnapshot == null) {\n            throw new IllegalArgumentException(\"One or both snapshots not found\");\n        }\n        \n        return new SnapshotComparison(oldSnapshot, newSnapshot);\n    }\n    \n    /**\n     * Restore code from snapshot\n     */\n    public CompletableFuture<String> restoreFromSnapshot(String snapshotId) {\n        return CompletableFuture.supplyAsync(() -> {\n            CodeSnapshot snapshot = snapshots.get(snapshotId);\n            if (snapshot == null) {\n                throw new IllegalArgumentException(\"Snapshot not found: \" + snapshotId);\n            }\n            \n            notifySnapshotRestored(snapshot);\n            return snapshot.getCode();\n        });\n    }\n    \n    /**\n     * Delete snapshot\n     */\n    public CompletableFuture<Boolean> deleteSnapshot(String snapshotId) {\n        return CompletableFuture.supplyAsync(() -> {\n            CodeSnapshot snapshot = snapshots.get(snapshotId);\n            if (snapshot == null) {\n                return false;\n            }\n            \n            // Remove from fileSnapshots\n            List<String> fileSnapList = fileSnapshots.get(snapshot.getFilePath());\n            if (fileSnapList != null) {\n                fileSnapList.remove(snapshotId);\n                if (fileSnapList.isEmpty()) {\n                    fileSnapshots.remove(snapshot.getFilePath());\n                }\n            }\n            \n            snapshots.remove(snapshotId);\n            deleteSnapshotFile(snapshotId);\n            \n            notifySnapshotDeleted(snapshotId);\n            return true;\n        });\n    }\n    \n    /**\n     * Search snapshots by tags or content\n     */\n    public List<CodeSnapshot> searchSnapshots(String query) {\n        String searchTerm = query.toLowerCase();\n        return snapshots.values().stream()\n                .filter(snapshot -> {\n                    return snapshot.getName().toLowerCase().contains(searchTerm) ||\n                           snapshot.getDescription().toLowerCase().contains(searchTerm) ||\n                           snapshot.getTags().stream().anyMatch(tag -> tag.toLowerCase().contains(searchTerm)) ||\n                           snapshot.getCode().toLowerCase().contains(searchTerm);\n                })\n                .sorted((s1, s2) -> s2.getTimestamp().compareTo(s1.getTimestamp()))\n                .collect(Collectors.toList());\n    }\n    \n    /**\n     * Get statistics about snapshots\n     */\n    public Map<String, Object> getStatistics() {\n        Map<String, Object> stats = new HashMap<>();\n        \n        stats.put(\"total_snapshots\", snapshots.size());\n        stats.put(\"files_with_snapshots\", fileSnapshots.size());\n        \n        // Count by file\n        Map<String, Integer> fileCounts = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : fileSnapshots.entrySet()) {\n            fileCounts.put(entry.getKey(), entry.getValue().size());\n        }\n        stats.put(\"snapshots_per_file\", fileCounts);\n        \n        // Auto vs manual snapshots\n        long autoCount = snapshots.values().stream().filter(CodeSnapshot::isAutomatic).count();\n        long manualCount = snapshots.size() - autoCount;\n        stats.put(\"automatic_snapshots\", autoCount);\n        stats.put(\"manual_snapshots\", manualCount);\n        \n        // Storage usage\n        long totalSize = snapshots.values().stream()\n                .mapToLong(CodeSnapshot::getFileSize)\n                .sum();\n        stats.put(\"total_storage_bytes\", totalSize);\n        stats.put(\"total_storage_formatted\", formatBytes(totalSize));\n        \n        // Most recent snapshot\n        CodeSnapshot mostRecent = snapshots.values().stream()\n                .max((s1, s2) -> s1.getTimestamp().compareTo(s2.getTimestamp()))\n                .orElse(null);\n        stats.put(\"most_recent_snapshot\", mostRecent);\n        \n        return stats;\n    }\n    \n    /**\n     * Export snapshots as backup\n     */\n    public CompletableFuture<String> exportSnapshots(String filePath) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                try (FileOutputStream fos = new FileOutputStream(filePath);\n                     ZipOutputStream zos = new ZipOutputStream(fos)) {\n                    \n                    for (CodeSnapshot snapshot : snapshots.values()) {\n                        ZipEntry entry = new ZipEntry(\"snapshots/\" + snapshot.getId() + \".json\");\n                        zos.putNextEntry(entry);\n                        \n                        String snapshotJson = serializeSnapshot(snapshot);\n                        byte[] data = snapshotJson.getBytes();\n                        zos.write(data, 0, data.length);\n                        zos.closeEntry();\n                    }\n                    \n                    // Add metadata\n                    ZipEntry metadataEntry = new ZipEntry(\"metadata.json\");\n                    zos.putNextEntry(metadataEntry);\n                    String metadataJson = createMetadataJson();\n                    byte[] metadataData = metadataJson.getBytes();\n                    zos.write(metadataData, 0, metadataData.length);\n                    zos.closeEntry();\n                }\n                \n                return filePath;\n                \n            } catch (Exception e) {\n                return null;\n            }\n        });\n    }\n    \n    /**\n     * Import snapshots from backup\n     */\n    public CompletableFuture<Integer> importSnapshots(String filePath) {\n        return CompletableFuture.supplyAsync(() -> {\n            int importedCount = 0;\n            \n            try (FileInputStream fis = new FileInputStream(filePath);\n                 ZipInputStream zis = new ZipInputStream(fis)) {\n                \n                ZipEntry entry;\n                while ((entry = zis.getNextEntry()) != null) {\n                    if (entry.getName().startsWith(\"snapshots/\") && entry.getName().endsWith(\".json\")) {\n                        StringBuilder json = new StringBuilder();\n                        byte[] buffer = new byte[1024];\n                        int length;\n                        while ((length = zis.read(buffer)) >= 0) {\n                            json.append(new String(buffer, 0, length));\n                        }\n                        \n                        CodeSnapshot snapshot = deserializeSnapshot(json.toString());\n                        if (snapshot != null) {\n                            snapshots.put(snapshot.getId(), snapshot);\n                            fileSnapshots.computeIfAbsent(snapshot.getFilePath(), k -> new ArrayList<>())\n                                        .add(snapshot.getId());\n                            importedCount++;\n                        }\n                    }\n                    zis.closeEntry();\n                }\n            } catch (Exception e) {\n                // Handle import error\n            }\n            \n            return importedCount;\n        });\n    }\n    \n    // Helper methods\n    private void loadSnapshots() {\n        // Load snapshots from storage\n        File storageDir = new File(storagePath);\n        if (!storageDir.exists()) {\n            storageDir.mkdirs();\n            return;\n        }\n        \n        File[] snapshotFiles = new File(storageDir, \"snapshots\").listFiles();\n        if (snapshotFiles != null) {\n            for (File file : snapshotFiles) {\n                if (file.getName().endsWith(\".json\")) {\n                    try {\n                        String snapshotId = file.getName().replace(\".json\", \"\");\n                        CodeSnapshot snapshot = loadSnapshotFile(snapshotId);\n                        if (snapshot != null) {\n                            snapshots.put(snapshot.getId(), snapshot);\n                            fileSnapshots.computeIfAbsent(snapshot.getFilePath(), k -> new ArrayList<>())\n                                        .add(snapshot.getId());\n                        }\n                    } catch (Exception e) {\n                        // Handle loading error\n                    }\n                }\n            }\n        }\n    }\n    \n    private void saveSnapshot(CodeSnapshot snapshot) {\n        try {\n            File snapshotFile = new File(storagePath, \"snapshots/\" + snapshot.getId() + \".json\");\n            String json = serializeSnapshot(snapshot);\n            \n            try (FileWriter writer = new FileWriter(snapshotFile)) {\n                writer.write(json);\n            }\n        } catch (Exception e) {\n            // Handle save error\n        }\n    }\n    \n    private void deleteSnapshotFile(String snapshotId) {\n        File snapshotFile = new File(storagePath, \"snapshots/\" + snapshotId + \".json\");\n        if (snapshotFile.exists()) {\n            snapshotFile.delete();\n        }\n    }\n    \n    private void cleanupAutoSnapshots(String filePath) {\n        List<String> autoSnapshotIds = fileSnapshots.getOrDefault(filePath, new ArrayList<>()).stream()\n                .filter(id -> {\n                    CodeSnapshot snapshot = snapshots.get(id);\n                    return snapshot != null && snapshot.isAutomatic();\n                })\n                .collect(Collectors.toList());\n        \n        if (autoSnapshotIds.size() >= maxAutoSnapshots) {\n            // Sort by timestamp and remove oldest\n            autoSnapshotIds.sort((id1, id2) -> {\n                CodeSnapshot s1 = snapshots.get(id1);\n                CodeSnapshot s2 = snapshots.get(id2);\n                return s1.getTimestamp().compareTo(s2.getTimestamp());\n            });\n            \n            // Remove oldest until we have maxAutoSnapshots - 1\n            for (int i = 0; i < autoSnapshotIds.size() - (maxAutoSnapshots - 1); i++) {\n                String oldId = autoSnapshotIds.get(i);\n                snapshots.remove(oldId);\n                fileSnapshots.get(filePath).remove(oldId);\n                deleteSnapshotFile(oldId);\n            }\n        }\n    }\n    \n    private String serializeSnapshot(CodeSnapshot snapshot) {\n        // Simple JSON serialization (in real implementation, use proper JSON library)\n        StringBuilder json = new StringBuilder();\n        json.append(\"{\");\n        json.append(\"\\\"id\\\": \\\"\").append(snapshot.getId()).append(\"\\\",\");\n        json.append(\"\\\"name\\\": \\\"\").append(escapeJson(snapshot.getName())).append(\"\\\",\");\n        json.append(\"\\\"description\\\": \\\"\").append(escapeJson(snapshot.getDescription())).append(\"\\\",\");\n        json.append(\"\\\"filePath\\\": \\\"\").append(escapeJson(snapshot.getFilePath())).append(\"\\\",\");\n        json.append(\"\\\"code\\\": \\\"\").append(escapeJson(snapshot.getCode())).append(\"\\\",\");\n        json.append(\"\\\"timestamp\\\": \\\"\").append(snapshot.getTimestamp()).append(\"\\\",\");\n        json.append(\"\\\"author\\\": \\\"\").append(escapeJson(snapshot.getAuthor())).append(\"\\\",\");\n        json.append(\"\\\"tags\\\": [\").append(\n            snapshot.getTags().stream()\n                    .map(tag -> \"\\\"\" + escapeJson(tag) + \"\\\"\")\n                    .collect(Collectors.joining(\", \"))\n        ).append(\"]\");\n        json.append(\"}\");\n        return json.toString();\n    }\n    \n    private CodeSnapshot deserializeSnapshot(String json) {\n        try {\n            // Simple JSON parsing (in real implementation, use proper JSON library)\n            if (!json.startsWith(\"{\") || !json.endsWith(\"}\")) {\n                return null;\n            }\n            \n            // Extract basic fields (simplified parsing)\n            String code = extractJsonField(json, \"code\");\n            String filePath = extractJsonField(json, \"filePath\");\n            String name = extractJsonField(json, \"name\");\n            String description = extractJsonField(json, \"description\");\n            \n            if (code == null || filePath == null) {\n                return null;\n            }\n            \n            CodeSnapshot snapshot = new CodeSnapshot(code, filePath, name, description);\n            snapshot.setAuthor(extractJsonField(json, \"author\"));\n            \n            return snapshot;\n            \n        } catch (Exception e) {\n            return null;\n        }\n    }\n    \n    private CodeSnapshot loadSnapshotFile(String snapshotId) {\n        File snapshotFile = new File(storagePath, \"snapshots/\" + snapshotId + \".json\");\n        if (!snapshotFile.exists()) {\n            return null;\n        }\n        \n        try {\n            StringBuilder json = new StringBuilder();\n            try (BufferedReader reader = new BufferedReader(new FileReader(snapshotFile))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    json.append(line);\n                }\n            }\n            \n            return deserializeSnapshot(json.toString());\n            \n        } catch (Exception e) {\n            return null;\n        }\n    }\n    \n    private String createMetadataJson() {\n        StringBuilder json = new StringBuilder();\n        json.append(\"{\");\n        json.append(\"\\\"version\\\": \\\"1.0\\\",\");\n        json.append(\"\\\"total_snapshots\\\": \").append(snapshots.size()).append(\",\");\n        json.append(\"\\\"created\\\": \\\"\").append(LocalDateTime.now()).append(\"\\\"\");\n        json.append(\"}\");\n        return json.toString();\n    }\n    \n    private String extractJsonField(String json, String fieldName) {\n        String pattern = \"\\\"\" + fieldName + \"\\\":\\\\s*\\\"([^\\\"]*)\\\"\");\n        Pattern p = Pattern.compile(pattern);\n        Matcher m = p.matcher(json);\n        if (m.find()) {\n            return m.group(1);\n        }\n        return null;\n    }\n    \n    private String escapeJson(String str) {\n        if (str == null) return \"\";\n        return str.replace(\"\\\\\", \"\\\\\\\\\")\n                  .replace(\"\\\"\", \"\\\\\\\"\")\n                  .replace(\"\\n\", \"\\\\n\")\n                  .replace(\"\\r\", \"\\\\r\")\n                  .replace(\"\\t\", \"\\\\t\");\n    }\n    \n    private String formatBytes(long bytes) {\n        if (bytes < 1024) return bytes + \" bytes\";\n        if (bytes < 1024 * 1024) return String.format(\"%.1f KB\", bytes / 1024.0);\n        return String.format(\"%.1f MB\", bytes / (1024.0 * 1024.0));\n    }\n    \n    private String getCurrentUser() {\n        // Get current user (simplified)\n        return System.getProperty(\"user.name\");\n    }\n    \n    // Notification methods\n    private void notifySnapshotCreated(CodeSnapshot snapshot) {\n        for (SnapshotListener listener : listeners) {\n            listener.onSnapshotCreated(snapshot);\n        }\n    }\n    \n    private void notifySnapshotDeleted(String snapshotId) {\n        for (SnapshotListener listener : listeners) {\n            listener.onSnapshotDeleted(snapshotId);\n        }\n    }\n    \n    private void notifySnapshotRestored(CodeSnapshot snapshot) {\n        for (SnapshotListener listener : listeners) {\n            listener.onSnapshotRestored(snapshot);\n        }\n    }\n    \n    // Public methods for external control\n    public void addSnapshotListener(SnapshotListener listener) {\n        listeners.add(listener);\n    }\n    \n    public void setAutoBackupEnabled(boolean enabled) {\n        this.autoBackupEnabled = enabled;\n    }\n    \n    public void setMaxAutoSnapshots(int max) {\n        this.maxAutoSnapshots = max;\n    }\n    \n    public boolean isAutoBackupEnabled() {\n        return autoBackupEnabled;\n    }\n    \n    public int getMaxAutoSnapshots() {\n        return maxAutoSnapshots;\n    }\n}